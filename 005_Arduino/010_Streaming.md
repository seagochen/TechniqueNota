@[TOC]

这一部分在Arduino官方中，名为Stream，为了避免跟视频的流处理混淆。我想到了数据串，以及数据串的流处理，合在一起让后取了一个简单的名字：串流处理。
可能不是很准确，不过在业界没有最终确定名字以前，就先这么叫着吧。

# 关于串流处理类——Stream

这是一个很基础的类，基本上Arduino的Serial、Wire、Ethernet，SD这些包都基于Stream进行了二次封装。大多数的情况下，你不需要使用这个类，你仅仅需要使用它的封装类，也就是继承类。不过这里还是提供给用户，以便于一些比较特殊的场景，尽管我认为一点用都没有。



## 获取可读取的字节数——available()

当接收到数据，这些数据都会以字节的形式存储在Serial的缓存中。而这个函数的作用，就时告诉用户或者程序，当前可以读取的字节数有多少。


## 读取字节——read()
读取数据，一次返回一个字节。


## 等待输出结束——flush()
数据开始发送后，可以使用这个函数，等待所有数据全部发送完毕。数据量少的时候，可以不使用这个函数。


## 查找指定的字节或字节串——find()

如果你的数据长度很大，比方说你要把一张图片编码成BASE６４，然后通过发送给Ａｒｄｕｉｎｏ，让它显示在某个LED或者LCD显示屏上，那么你可能需要使用这个指令。

它的作用是在接收到的字节缓存中，从第一位开始逐个查找指定的字节或字节组合（例如特定的字符串），所以你可以用它来检测自定义的数据包头或者包尾。找到则返回Ｔｒｕｅ，超时或者没有找到则返回Ｆａｌｓｅ。

## 查找指定的字节或字节串，直到终止符——findUntil()
和**find**函数很相似，只不过多了一个同时查找终止符的功能，相当在缓存中**查找指定字符，直到找到终止符**，找到则返回Ｔｒｕｅ，超时或者没有找到则返回Ｆａｌｓｅ。


## 查找第一个有效字节——peek()
它的主要作用是帮你在Serial的缓存中找到下一个正确的字节（开始的第一个字节）。连续的调用都将得到第一个字节的位子。如果使用ｒｅａｄ函数，则会返回下一个字节。

## 读取字节串——readBytes()
readBytes比read稍微多了一点功能，就是一次性可以取出一块数据。比一个一个读取字节要快不少，当然也可能比较容易出错。


## 读取字节数据，直到终止符——readBytesUntil()

从缓存读取指定长度的字符到数组buffer，遇到终止字符character后停止。


## 读取字符数据——readString()

从缓存区读取全部数据到一个字符串型变量。

## 读取字符数据，直到终止符——readStringUntil()

从缓存区读取字符到一个字符串型变量，直至读完或遇到某终止字符。


## 解析浮点数——parseFloat()

从接收到的数据中，逐个进行解析，直到找到第一个合法的浮点数，并返回给用户。


## 解析整型数——parseInt()

和上一个函数的作用十分相似，也是返回第一个合法的整型数据。但无论parseFloat还是parseInt都有个等待时间，超时后任务中止，会直接进入到下个环节。


## 超时管理——setTimeout()

所有的IO通信都存在着超时处理，自然Stream也提供了超时处理。默认的超时时间是1s，即1000 milliseconds.


# 后记
你看，如果你查阅过Serial的相关手册，就会发现有很多设置和函数名是一模一样的，由于Arduino跟其他设备的通信，主要通过I2C以及串口，及普通电平针脚。所以你其实更应该花点时间熟悉和使用具体的类函数，Stream相当于一个基类，所以我们了解一下其中的一些基础功能就足够了。